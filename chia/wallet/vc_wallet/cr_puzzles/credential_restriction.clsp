(mod
  (
    THIS_MOD_HASH
    CREDENTIAL_STRUCT
    AUTHORIZED_PROVIDERS
    PROOFS_CHECKER
    INNER_PUZZLE
    proof_of_inclusions
    proof_checker_solution
    provider_id
    credential_id
    credential_inner_puzhash
    my_coin_id
    inner_solution
  )

  (include curry.clib)
  (include condition_codes.clvm)
  (include sha256tree.clib)
  (include utility_macros.clib)

  (defconstant announcement_namespace 0xcd)

  (defun-inline wrap_puzhash
    (
      THIS_MOD_HASH
      CREDENTIAL_STRUCT_HASH
      AUTHORIZED_PROVIDERS_HASH
      PROOFS_CHECKER_HASH
      puzhash
    )

    (curry_hashes THIS_MOD_HASH
      (sha256 1 THIS_MOD_HASH)
      CREDENTIAL_STRUCT_HASH
      AUTHORIZED_PROVIDERS_HASH
      PROOFS_CHECKER_HASH
      puzhash
    )
  )

  ; Does three things:
  ; 1) Wraps create coins with this layer
  ; 2) Announces those create coins in a namespace
  ; 3) Raises on announcements from the inner puzzle that could possibly be in the namespace
  (defun process_conditions
    (
      THIS_MOD_HASH
      CREDENTIAL_STRUCT_HASH
      AUTHORIZED_PROVIDERS_HASH
      PROOFS_CHECKER_HASH
      conditions
    )
    (if conditions
        (if (= (f (f conditions)) CREATE_COIN)
            (c
              (list
                CREATE_COIN_ANNOUNCEMENT
                (concat
                  announcement_namespace
                  (sha256 (f (r (f conditions))) (f (r (r (f conditions)))))
                )
              )
              (c
                (c
                  CREATE_COIN
                  (c
                    (wrap_puzhash THIS_MOD_HASH CREDENTIAL_STRUCT_HASH AUTHORIZED_PROVIDERS_HASH PROOFS_CHECKER_HASH (f (r (f conditions))))
                    (r (r (f conditions)))
                  )
                )
                (process_conditions THIS_MOD_HASH CREDENTIAL_STRUCT_HASH AUTHORIZED_PROVIDERS_HASH PROOFS_CHECKER_HASH (r conditions))
              )
            )
            ; else - not a create coin
            (assert (or
                (not (= (f (f conditions)) CREATE_COIN_ANNOUNCEMENT))  ; some coin announcements should be blocked
                (not (= 33 (strlen (f (r (f conditions))))))  ; we only care about blocking 0xcd + some_hash
                (not (= announcement_namespace (substr (f (r (f conditions))) 0 1))) ; block prefix 0xcd
              )
              ; then
              (c
                (f conditions)
                (process_conditions THIS_MOD_HASH CREDENTIAL_STRUCT_HASH AUTHORIZED_PROVIDERS_HASH PROOFS_CHECKER_HASH (r conditions))
              )
            )
        )
        ; else - end of list
        ()
    )
  )

  (defun-inline vc_puzhash_stager_2
    (
      SINGLETON_MOD_HASH
      OWNERSHIP_LAYER_MOD_HASH
      ADAPTER_MOD_HASH
      COVENANT_MOD_HASH
      NFT_DID_TP_MOD_HASH
      provider_id
      credential_singleton_struct_hash
      proof_hash
      credential_inner_puzhash
      initial_singleton_inner_puzhash_hash
      parent_morpher_hash
    )

    (curry_hashes SINGLETON_MOD_HASH
      credential_singleton_struct_hash
      (curry_hashes OWNERSHIP_LAYER_MOD_HASH
        (sha256 1 OWNERSHIP_LAYER_MOD_HASH)
        (sha256 1 (sha256 2
          (sha256 1 provider_id)
          (sha256 1 proof_hash)
        ))
        (curry_hashes ADAPTER_MOD_HASH
          (curry_hashes COVENANT_MOD_HASH
            initial_singleton_inner_puzhash_hash
            (curry_hashes parent_morpher_hash
              (sha256 1 parent_morpher_hash)
            )
            NFT_DID_TP_MOD_HASH
          )
        )
        credential_inner_puzhash
      )
    )
  )

  (defun vc_puzhash_stager
    (
      (
        SINGLETON_MOD_HASH
        SINGLETON_LAUNCHER_HASH
        OWNERSHIP_LAYER_MOD_HASH
        ADAPTER_MOD_HASH
        INITIAL_SINGLETON_INNER_PUZHASH
        COVENANT_MOD_HASH
        OL_PARENT_MORPHER_MOD_HASH
        NFT_DID_TP_MOD_HASH
      )
      provider_id
      credential_singleton_struct_hash
      proof_hash
      credential_inner_puzhash
      initial_singleton_inner_puzhash_hash
    )

    (vc_puzhash_stager_2
      SINGLETON_MOD_HASH
      OWNERSHIP_LAYER_MOD_HASH
      ADAPTER_MOD_HASH
      COVENANT_MOD_HASH
      NFT_DID_TP_MOD_HASH
      provider_id
      credential_singleton_struct_hash
      proof_hash
      credential_inner_puzhash
      initial_singleton_inner_puzhash_hash
      (curry_hashes OL_PARENT_MORPHER_MOD_HASH
        (sha256 1 COVENANT_MOD_HASH)
        (sha256 1 OWNERSHIP_LAYER_MOD_HASH)
        (sha256 1 ADAPTER_MOD_HASH)
        (sha256 1 SINGLETON_MOD_HASH)
        (sha256 1 SINGLETON_LAUNCHER_HASH)
        (sha256 1 NFT_DID_TP_MOD_HASH)
      )
    )

  )

  (defun create_vc_puzhash
    (
      CREDENTIAL_STRUCT
      provider_id
      credential_singleton_struct_hash
      proof_hash
      credential_inner_puzhash
    )

    (vc_puzhash_stager
      CREDENTIAL_STRUCT
      provider_id
      credential_singleton_struct_hash
      proof_hash
      credential_inner_puzhash
      (sha256 1 (curry_hashes (f CREDENTIAL_STRUCT)
        credential_singleton_struct_hash
        (f (r (r (r (r CREDENTIAL_STRUCT)))))
      ))
    )
  )

  ; utility function that turns the output of two calls to collapse_tree_and_note_leaf_info into a single return value
  (defun branch_hash_and_merge_info ((TREE1 PROOFS1) (TREE2 PROOFS2))
    (list
      (sha256 TWO TREE1 TREE2)
      (merge_list PROOFS1 PROOFS2)
    )
  )

  (defun collapse_tree_and_note_leaf_info (TREE PROOFS)
    (if (l TREE)
        (if (or (l (f TREE)) (l (r TREE)))  ; If either side is a cons, we have not reached a leaf pair yet
            (branch_hash_and_merge_info
              (collapse_tree_and_note_leaf_info (f TREE) ())
              ; we favor right because merge_list merges from left
              (collapse_tree_and_note_leaf_info (r TREE) PROOFS)
            )
            (branch_hash_and_merge_info
              (list (sha256 1 (f TREE)) ())
              (list (sha256 1 (r TREE)) (c TREE PROOFS))
            )
        )
        (list TREE PROOFS)  ; All atoms that we reach must be pre-hashed subtrees
    )
  )

  (defun main
    (
      THIS_MOD_HASH
      CREDENTIAL_STRUCT
      AUTHORIZED_PROVIDERS
      PROOFS_CHECKER
      proof_checker_solution
      provider_id
      credential_id
      credential_inner_puzhash
      my_coin_id
      conditions
      (tree_hash proofs)
    )

    (assert
      (a PROOFS_CHECKER (c proofs proof_checker_solution))
      (in provider_id AUTHORIZED_PROVIDERS)
      ; then
      (c
        (list ASSERT_MY_COIN_ID my_coin_id)
        (c
          (list ASSERT_PUZZLE_ANNOUNCEMENT
              (sha256
                (create_vc_puzhash
                  CREDENTIAL_STRUCT
                  provider_id
                  (sha256tree (c (f CREDENTIAL_STRUCT) (c credential_id (f (r CREDENTIAL_STRUCT)))))
                  tree_hash
                  credential_inner_puzhash
                )
                (sha256 my_coin_id 0xca)
              )
          )
          (process_conditions
            THIS_MOD_HASH
            (sha256tree CREDENTIAL_STRUCT)
            (sha256tree AUTHORIZED_PROVIDERS)
            (sha256tree PROOFS_CHECKER)
            conditions
          )
        )
      )
    )
  )

  (main
    THIS_MOD_HASH
    CREDENTIAL_STRUCT
    AUTHORIZED_PROVIDERS
    PROOFS_CHECKER
    proof_checker_solution
    provider_id
    credential_id
    credential_inner_puzhash
    my_coin_id
    (a INNER_PUZZLE inner_solution)
    (collapse_tree_and_note_leaf_info proof_of_inclusions ())
  )

)